You are an expert full-stack developer with deep knowledge in modern web development, including React, Next.js, Node.js, databases, UI libraries, and performance optimization. Your task is to refactor the entire Audiobookshelf application from the GitHub repository at https://github.com/advplyr/audiobookshelf. The goal is to create an identical application in terms of features, functionality, user interface, and user experience, but rebuilt from the ground up using the absolute best bleeding-edge practices as of December 2025.Core Requirements:Exact Replication: The refactored app must be functionally identical to the original. This includes all features such as audiobook and podcast management, user authentication, library scanning, metadata handling, playback controls, progress tracking, multi-user support, mobile responsiveness, and any admin tools. Do not add or remove any features unless explicitly specified below. Preserve the same API endpoints, data structures, and behaviors where possible.
Tech Stack Overhaul:Frontend: Use Next.js 16 (latest stable version) with React 19. Implement Server-Side Rendering (SSR), Static Site Generation (SSG), and React Server Components (RSC) where optimal for performance. Use TypeScript exclusively for type safety.
UI Framework: Completely replace the existing UI with Tailwind CSS (latest version) for styling and Shadcn/UI (latest version) for reusable components. Ensure the UI looks and feels exactly like the original, pixel-perfect where possible, but leverage Shadcn's accessible, customizable components (e.g., buttons, modals, tables, accordions, etc.). Use Tailwind's JIT mode and dark mode support natively.
Backend/Database: Use Supabase (latest version) for the primary database (PostgreSQL via Supabase), real-time features, storage (for audio files and covers), and authentication (with email/password, OAuth providers like Google, and row-level security). Migrate all core data models (users, libraries, books, podcasts, sessions, etc.) to Supabase tables with proper schemas, indexes, and RLS policies to match the original's security and access controls. For analytics (e.g., usage tracking, listening stats, performance metrics), integrate MotherDuck DB (latest version) as a serverless analytics data warehouse. Sync relevant data from Supabase to MotherDuck for querying and reporting, using DuckDB-based optimizations for fast analytics.
Authentication: Exclusively use Supabase Auth for all user management, sessions, and access controls, ensuring seamless integration with Next.js middleware for protected routes.
Caching/Queueing: Integrate Upstash (latest version) for serverless Redis-based caching (e.g., for metadata, session data) and rate limiting to handle high-traffic scenarios efficiently.
State Management: Use TanStack Query (React Query) for data fetching and caching, Zustand or Jotai for lightweight global state where needed. Avoid Redux unless absolutely necessary for complex scenarios.
API Layer: Implement a clean API layer using Supabase's JavaScript client. For any custom server logic, use Supabase Edge Functions or Next.js API routes with server actions. For analytics queries, use MotherDuck's SDK or direct SQL integrations.
Git Hooks: Use Lefthook (latest version) to manage Git hooks for pre-commit linting, testing, and formatting to enforce code quality.
Performance Optimizations: Implement bleeding-edge practices like partial prerendering in Next.js, image optimization with next/image, lazy loading, code splitting, and bundle size minimization. Use Web Vitals monitoring and aim for perfect Lighthouse scores (100/100 across performance, accessibility, best practices, SEO). Ensure Vercel readiness with optimized build configurations, environment variables, and deployment hooks for seamless Vercel hosting.
Testing: Include unit tests with Vitest, integration tests with Playwright, and end-to-end tests. Aim for 90%+ code coverage.
Deployment: Structure the app for easy deployment to Vercel (for Next.js) with Supabase, MotherDuck, and Upstash integrations. Include Dockerfiles and CI/CD workflows using GitHub Actions for automated testing and deployment. Optimize for Vercel features like previews, analytics, and speed insights.
Security: Follow OWASP top 10, implement CSP, rate limiting via Upstash, input validation, and use Supabase's built-in security features.
Accessibility: Ensure WCAG 2.2 AA compliance using Shadcn's accessible components and ARIA attributes.
Internationalization: If the original supports i18n, replicate it using next-intl.

Specific Additions:Advanced GPU Rendering for 120Hz: Enhance the app with GPU-accelerated rendering for ultra-smooth performance, targeting 120Hz refresh rates on supported devices (e.g., high-end mobiles, monitors). Use WebGL via Three.js or PixiJS for any visual elements like waveform visualizations, cover art animations, or progress bars. Implement requestAnimationFrame optimizations, CSS GPU acceleration (e.g., will-change: transform), and integrate with the WebGPU API (if stable by 2025) for hardware-accelerated rendering of audio visualizations or UI transitions. Ensure fallback to CPU rendering for non-GPU devices. This should make playback controls, scrolling libraries, and animations feel buttery smooth at 120fps without jank.

Refactoring Process:Analyze Original Code: Start by thoroughly reviewing the entire repository: structure, components, routes, database schemas (original uses SQLite/MongoDB-like, migrate to Supabase Postgres with analytics to MotherDuck), authentication flow, file handling, etc.
Break Down into Modules: Refactor modularly â€“ e.g., auth module (using Supabase Auth), library module, player module, admin module. For each:Rewrite frontend components with Shadcn + Tailwind.
Migrate backend logic to Supabase queries/functions, with analytics piped to MotherDuck.
Ensure data flow matches original (e.g., real-time updates via Supabase subscriptions, cached via Upstash).

Migration Guide: Provide a step-by-step migration guide in the README, including how to export data from the original app and import into Supabase/MotherDuck.
Edge Cases: Handle all edge cases from the original, like large libraries, offline support (using Service Workers and IndexedDB for caching), mobile app integration if applicable.
Documentation: Update README.md with setup instructions, environment variables (e.g., SUPABASE_URL, SUPABASE_ANON_KEY, MOTHERDUCK_TOKEN, UPSTASH_REDIS_REST_URL), and architecture overview. Include API docs with Swagger or similar. Add Lefthook configuration for hooks.

Output Format:Generate the complete refactored codebase as a zip file structure, but since this is text-based, output it as a detailed file tree with code snippets for key files (e.g., app/layout.tsx, components/Player.tsx, lib/supabase.ts, lib/motherduck.ts, etc.). For large files, provide pseudocode or summaries, but aim for completeness.
Include a diff summary highlighting changes from the original.
If the full code is too long, prioritize core files and provide instructions on how to generate the rest.
Finally, output a working demo URL or instructions to run locally (e.g., npm install, npm run dev, with Supabase, MotherDuck, and Upstash setup).

Ensure the refactored app is production-ready, scalable, and maintains the open-source spirit (MIT license). If any part is unclear, make best-practice assumptions based on modern standards.

